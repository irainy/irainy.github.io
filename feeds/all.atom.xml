<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>rainy</title><link href="http://defsniky.com/" rel="alternate"></link><link href="http://defsniky.com/feeds/all.atom.xml" rel="self"></link><id>http://defsniky.com/</id><updated>2014-05-21T00:00:00+08:00</updated><entry><title>恶补概率统计（一）</title><link href="http://defsniky.com/posts/2014-05-21-math-and-statistics-relearning-part-1.html" rel="alternate"></link><updated>2014-05-21T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-05-21:posts/2014-05-21-math-and-statistics-relearning-part-1.html</id><summary type="html">&lt;p&gt;之前(&lt;a href="/posts/2014-05-14-Why-using-SVM-in-scene-categorization-always.html"&gt;Why SVM&lt;/a&gt;)整理的几篇关于场景识别的计算模型，其中一个是Bayesian Hierarchical Model，还有就是最近比较热门的LDA(Latent Dirichlet Allocation)主题模型。LDA首先由Blei, David M.，Ng, Andrew Y.和Jordan, Michael I于2003年提出，比较成熟地应用于文本挖掘、文本主题识别等领域，后来被引入到图像场景识别中，包括Li Fei-Fei教授的Bayesian Hierarchical Model其实也是应用的LDA模型，但又因为LDA本身就是一个三层贝叶斯模型(three-level hierarchical Bayesian model)，只不过在具体应用过程中还有所不同，后面详细描述几个模型的时候将会提到。&lt;/p&gt;
&lt;p&gt;总而言之一句话，LDA模型很重要，但是涉及到很多概率统计的东西，仔细一看才发现，以前学过的基本已经忘得差不多了，只好恶补一下，网上有很多介绍LDA的文章，但是良莠不齐，抄袭者、昏昏者居多，但是&lt;a href="http://cos.name/author/rickjin/"&gt;rickjin&lt;/a&gt;大牛发表在&lt;a href="http://cos.name/author/rickjin/"&gt;统计之都&lt;/a&gt;的一系列文章绝对值得细细拜读。&lt;/p&gt;
&lt;p&gt;下面的内容将会是结合rickjin的文章以及重新学习整理过的一些知识点有助于学习、理解LDA模型：&lt;/p&gt;
&lt;h3&gt;1. 伯努利实验与二项分布&lt;/h3&gt;
&lt;p&gt;伯努利试验就是著名的抛硬币实验，抛一次硬币得到正面的概率为 $p$，得到反面的概率为 $q = 1 - p$；而二项分布(Binomial)就是 $n$ 次独立的伯努利试验中成功(得到正面)次数的分布 $X \sim B(n, p)$：$$P(k;n,p) = C^n_k p^k (1-p)^{n-k}$$&lt;/p&gt;
&lt;h3&gt;2. 多项式分布(Multinomial distribution)&lt;/h3&gt;
&lt;p&gt;将二项分布进行扩展，如果抛的不是只有两面的硬币，而是一个有 $k$ 个面的骰子，相互独立地抛 $N$ 次，那么数字 $i$ 出现的次数 $K_i$ 服从多项式分布；假设出现数字 $i$ 的概率为 $p_i$ ，则满足 $(p_1 + p_2 + ... + p_k) = \sum{p_i} = 1$，将 $N$ 次独立抽样看作是从 $N$ 次多项式全部展开后取其中 $i$ (概率为 $p_i$ )出现次数为 $K_i$的概率：
$$(p_1 + p_2 + ... + p_k) (p_1 + p_2 + ... + p_k) ... = (p_1 + p_2 + ... + p_k)^N = 1$$
那么数字 $i$ 出现 $K_i$ 的次数满足：
$$P( \vec{K};N, \vec{p} ) =   \frac{n!}{K_i!K_2!...K_k}  p^{K_1}p^{K_2}...p^{K_k}$$
在主题模型中，假设文档 $D$ 中的所有词语 $\vec{W}=(w_1, w_2,..., w_N)$ 就是从 $k$ 个 topic 中进行了 $N$ 次独立取样得到的，那么从 $k$ 个 topic 中生成 $N$ 个词语，其中词语 $w_i$ 出现了 $k_i$ 次(即得到 $\vec{W}$ )的概率服从多项式分布。&lt;/p&gt;
&lt;h3&gt;3. 贝叶斯概率论&lt;/h3&gt;
&lt;p&gt;前面提到 LDA 是一个三层贝叶斯模型而不是简单的多项式分布，因此不得不提贝叶斯学派的概率理论。经典学派的观点认为概率是&lt;strong&gt;大量重复实验频率的稳定值&lt;/strong&gt;，因此也称作频率派；而贝叶斯学派赞成&lt;strong&gt;主观概率&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;People apparently want statistics to tell them the probability of their hypothesis being right. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如在抛硬币实验中我们不应该只考虑最终客观的统计频率，还要将我们对骰子本身特性的先验知识考虑在内。假设随机变量 $X \sim f(X, \theta)$ ，频率派将 $X$ 当做可重复实验的随机变量，而 $\theta$ 当做是概率分布中&lt;strong&gt;确定但未知&lt;/strong&gt;的参数，因此 $f(X, \theta)$ 反应的是 $X$ 的规律特性，$\theta$ 是可以通过对 $X$ 的抽样进行估计的。但是在贝叶斯派的观点中，未知的参数 $\theta$ 并&lt;strong&gt;不是确定的&lt;/strong&gt;，它自身服从自己的先验概率分布：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在贝叶斯学派看来，一切参数都是随机变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而贝叶斯的基本公式是：
$$P(H|D)  \propto  P(H) P(D|H)$$
也就是说我们最终观察到的&lt;strong&gt;后验概率&lt;/strong&gt; $P(H|D)$ 是由我们对假设 $H$ 本身的&lt;strong&gt;先验知识&lt;/strong&gt; $P(H)$ 与在先验知识的基础上观察得到的新数据即&lt;strong&gt;相似度&lt;/strong&gt; $P(D|H)$ 决定的；接下来问题就来了，对于先验知识，我们并不总是能够准确地知道其遵循什么样的规律，服从什么样的分布，如何选取先验分布是一个相当重要的问题，确定先验分布的方法有：客观法、主观概率法、同等物质原则、共轭分布法、Jeffreys原则、最大熵原则等。这里需要着重介绍的就是&lt;strong&gt;共轭分布法&lt;/strong&gt;。所谓的共轭分布就是指当 $P(D|H)$ 遵循某种分布时先验分布和后验分布遵循相同的分布形式，只是参数不同而已，例如常见的共轭分布有：Beta-Binomial 共轭、Gamma-Dirichlet 共轭，结合上面提到的主题模型中得多项式分布，可以知道 LDA 模型中所采取的先验概率即为 Gamma 分布。&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="Psychology"></category><category term="统计"></category><category term="LDA"></category></entry><entry><title>做一个可视化网络的标签云</title><link href="http://defsniky.com/posts/2014-05-18-tag-cloud-network-visualization.html" rel="alternate"></link><updated>2014-05-18T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-05-18:posts/2014-05-18-tag-cloud-network-visualization.html</id><summary type="html">&lt;p&gt;想要制作一个标签云：每一个标签(Tag)都像是一个topic，不同的topic之间通过文章联系起来，即不同的topic出现在同一篇文章中就形成一个更大的主题，因此自然而然地想到用网络的形式呈现，先看一下&lt;a href="/tags.html"&gt;Demo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="network" src="/theme/images/blog/network.png" /&gt;&lt;/p&gt;
&lt;p&gt;首先想要用 &lt;code&gt;Javascript&lt;/code&gt; 实现可视化网络的话要选一个可视化工具库，最先想到的是&lt;a href="http://d3js.org/"&gt;D3&lt;/a&gt;，但后来发现用起来并不顺利，最后选用了一个小巧的&lt;a href="http://getspringy.com/"&gt;Springy.js&lt;/a&gt;，它包含两个部分，一是计算网络属性&lt;code&gt;Node &amp;amp; Edge&lt;/code&gt;等(&lt;a href="https://github.com/dhotson/springy/blob/master/springy.js"&gt;springy.js&lt;/a&gt;)，另一个基于 HTML5 的 Canvas 对网络进行绘制(&lt;a href="https://github.com/dhotson/springy/blob/master/springyui.js"&gt;springyui.js&lt;/a&gt;)。接下来要获取标签的统计以及标签之间的联系，因为我是用&lt;a href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;生成网站的，因此就想要自己写一个 plugin 在生成网站的时候统计文章标签的情况(&lt;a href="http://git.oschina.net/sniky/pelican-blog/blob/master/plugins/tagsnet/tagsnet.py"&gt;代码&lt;/a&gt;)，其中关于网络的 &lt;code&gt;Node &amp;amp; Edge&lt;/code&gt; 数据格式部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;None&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Url&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ID&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Url&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;Link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Src&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Src&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Tar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Tar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来在页面中用&lt;code&gt;Springy&lt;/code&gt;生成网络，其中&lt;code&gt;addNodes&lt;/code&gt; 与 &lt;code&gt;addEdges&lt;/code&gt;方法为适应上面生成的统计数据而进行了调整(&lt;a href="http://git.oschina.net/sniky/pelican-blog/blob/master/themes/theme-by-rainy/static/js/springy.js#L87"&gt;addNodes&lt;/a&gt;, &lt;a href="http://git.oschina.net/sniky/pelican-blog/blob/master/themes/theme-by-rainy/static/js/springy.js#L140"&gt;addEdges&lt;/a&gt;)，同时为&lt;code&gt;Node.data&lt;/code&gt;添加了&lt;code&gt;ondoubleclick&lt;/code&gt;的属性使标签在双击条件下跳转，正常的拖拽、选中不会产生跳转：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;graph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Springy&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addNodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Network&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nodes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="nx"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEdges&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Network&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;links&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="nx"&gt;jQuery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;springy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;springy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;jQuery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#tagsnet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;springy&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;graph&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;graph&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="FUN"></category><category term="Javascript"></category></entry><entry><title>Why SVM</title><link href="http://defsniky.com/posts/2014-05-14-Why-using-SVM-in-scene-categorization-always.html" rel="alternate"></link><updated>2014-05-14T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-05-14:posts/2014-05-14-Why-using-SVM-in-scene-categorization-always.html</id><summary type="html">&lt;p&gt;自然场景识别或分类无论是在机器视觉(Computer Vision)领域还是认知心理学的研究范畴中都离不开机器学习算法的辅助，而机器学习算法中至关重要的两个步骤分别是提取(选取)特征与学习算法。最近读到一系列关于场景识别的心理学研究，通常会用SVM算法与人类观察者实验结果进行对比，并据以论证所假设的某些特征在场景识别中的有效性，且先不说这一论证方法逻辑的可靠性，为什么多数研究会采用SVM算法呢？&lt;/p&gt;
&lt;p&gt;首先看一下SVM(Support Vector Machine)算法，SVM是一种扩展的线性模型，它通过非线性映射的转换，将特征空间转换为一个维度更高的空间，从而实现非线性分类边界的划分，下面这张图能够很好第说明这一特点，原本二维空间里面线性不可分的两类，投射到三维空间后就变得很好区分了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="svm" src="/theme/images/blog/svm.gif" title="“SVM”" /&gt;&lt;/p&gt;
&lt;p&gt;除此之外它还具有另外一些有点，例如SVM是取能够区分两个类别中“相距”最小的实例之间的决策平面，因而能够很好地规避过度拟合的现象(Overfitting，具体可参考&lt;a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/05/02/basic-of-svm.html"&gt;机器学习中的算法(2)-支持向量机(SVM)基础&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;除了SVM之外还有许多其它分类算法，例如Logistic回归(就是把线性回归掰弯)、神经网络等，尤其是人工神经网络(ANN)算法，由于其神经网络的隐喻与心理学之间“暧昧”的关系，确实也有见过认知心理学研究甚至直接拿训练神经网络作为认知模型，但在场景识别的研究中却很少见。SVM与神经网络都是基于线性模型发展出来的，但两派的纷争却一直不断，SVM算法的出现凭借着对小样本量的支持、易于实现、计算复杂度较小等优点一度占尽了风头，在认知心理学研究中的广泛应用从某种程度上来说也佐证了其众多优点。不过最近深度学习(Deep learning, 多层神经网络)算法的快速走红，不知道会不会给场景识别研究也带来新的春天？&lt;/p&gt;
&lt;p&gt;然而毕竟心理学研究不是为了追逐新潮的算法，我们更加关注的是人类行为背后的认知加工机制，大家采用同样的机器学习算法可能也是为了彼此研究之间的横向对比，因此在计算机视觉中更加注重的是算法的效能，包括准确率、健壮性、欠拟合过度拟合等问题，而在心理学研究中应用机器学习算法更加关注的是其分类结果中的错误模式(Error Pattern)，并将其与人类观察者的行为结果进行对比，从而验证关于&lt;strong&gt;特征选取&lt;/strong&gt;的假设，而算法的优劣则更像是一种系统偏差。&lt;/p&gt;
&lt;p&gt;当然除了SVM算法之外，场景识别研究也有很多心理学与计算机视觉交叉的研究方法与结果，包括很多JoV与CVPR等刊出的研究结果很有参考价值，下面列出几个非常重要的关于场景识别的计算模型，同样也是非常经典的认知模型(按发表时间顺序)，后续将会逐一介绍：&lt;/p&gt;
&lt;h4&gt;1. Spatial Envelope&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Oliva&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Torralba&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2001&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt; &lt;span class="n"&gt;Modeling&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;scene&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;holistic&lt;/span&gt; &lt;span class="n"&gt;representation&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;spatial&lt;/span&gt; &lt;span class="n"&gt;envelope&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. Bayesian Hierarchical Model&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Fei&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Fei&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Perona&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2005&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;bayesian&lt;/span&gt; &lt;span class="n"&gt;hierarchical&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;learning&lt;/span&gt; &lt;span class="n"&gt;natural&lt;/span&gt; &lt;span class="n"&gt;scene&lt;/span&gt; &lt;span class="n"&gt;categories&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3. Contextual Guidance Model&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Torralba&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="n"&gt;Oliva&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="n"&gt;Castelhano&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Henderson&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2006&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt; &lt;span class="n"&gt;Contextual&lt;/span&gt; &lt;span class="n"&gt;guidance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;eye&lt;/span&gt; &lt;span class="n"&gt;movements&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;attention&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="n"&gt;scenes&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;role&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;global&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4. Bag of Visual Word(LDA系列的主题模型，选取最近一篇fMRI研究)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Stansbury&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="n"&gt;Naselaris&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Gallant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt; &lt;span class="n"&gt;Natural&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="n"&gt;Statistics&lt;/span&gt; &lt;span class="n"&gt;Accountfor&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;Representation&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="n"&gt;Categories&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt; &lt;span class="n"&gt;Visual&lt;/span&gt; &lt;span class="n"&gt;Cortex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Psychology"></category><category term="SVM"></category><category term="场景识别"></category><category term="Vision"></category></entry><entry><title>What's this in Javascript</title><link href="http://defsniky.com/posts/2014-04-28-what-is-this-in-javascript.html" rel="alternate"></link><updated>2014-04-28T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-04-28:posts/2014-04-28-what-is-this-in-javascript.html</id><summary type="html">&lt;p&gt;&lt;img alt="咬尾蛇" src="/theme/images/blog/ouroboros.png" title="咬尾蛇" /&gt;&lt;/p&gt;
&lt;p&gt;this是Javascript中的一个关键字，由于Javascript并没有“类”(class)的概念，致使这里的this与其它面向对象的语言中诸如&lt;code&gt;this&lt;/code&gt;、&lt;code&gt;self&lt;/code&gt;等关键字的含义存在一定的差异，而容易造成的误解。在面向对象的语言中&lt;code&gt;this&lt;/code&gt;指向类的实例对象，在实例化之后通过&lt;code&gt;this&lt;/code&gt;调用的属性或方法会被自动指向类作用域中的属性或方法，同样的，Javascript中的&lt;code&gt;this&lt;/code&gt;也用于指向特定的作用域，只不过因为JavaScript中没有类作用域的概念，而是采用作用域链(Scope Chain)的方式管理上下文，因而需要根据不同的应用场景判定&lt;code&gt;this&lt;/code&gt;所指向的内容。&lt;/p&gt;
&lt;p&gt;首先，在Chrome Console或Node中直接输入&lt;code&gt;this&lt;/code&gt;，得到的是&lt;code&gt;Window&lt;/code&gt;对象或Node中的全局对象（以下以Console为例，因为突然发现&lt;code&gt;console.log()&lt;/code&gt;跟&lt;code&gt;alert()&lt;/code&gt;还是有差别的:P），这时&lt;code&gt;this&lt;/code&gt;指向全局变量（或者说它是全局变量的指针），这时的&lt;code&gt;this&lt;/code&gt;默认是隐含的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//在全局环境中&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//等价于this.x = 1&lt;/span&gt;
&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;//输出1&lt;/span&gt;
&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;//输出1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当&lt;code&gt;this&lt;/code&gt;在函数中被使用的时候，类似一个递归的过程，&lt;code&gt;this&lt;/code&gt;指向调用该函数的（全局或对象）作用域，即只要看“包裹”函数的作用域即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//新的环境&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//undefined, 因为此时调用test()的是全局作用域，而全局作用域中没有定义x&lt;/span&gt;
&lt;span class="nx"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//1, 因为调用test()的是obj作用域，而obj.x = 1，在这里其功能已经类似于面向对象的this指针了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外一种比较特殊的情况是，当使用&lt;code&gt;new&lt;/code&gt;关键字构造新的对象时，被&lt;code&gt;new&lt;/code&gt;的函数就不是普通的函数了，它变成了一个“构造函数”，此时会自动给它“包裹”上一层对象作用域：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//新的环境&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;None&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;rainy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;rainy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;rainy&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// &amp;#39;rainy&amp;#39;, 不再是undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;好久没有更新，关于&lt;code&gt;this&lt;/code&gt;在看《JavaScript高级程序设计》时就想整理一下，一直拖到现在。Javascript中的&lt;code&gt;this&lt;/code&gt;容易被混淆更多的是因为其&lt;strong&gt;作用域链&lt;/strong&gt;与&lt;strong&gt;原型链&lt;/strong&gt;的概念与一般语言尤其是面向对象语言的作用域规则相差较多；而&lt;code&gt;this&lt;/code&gt;关键字本身有趣的地方在于它存在于对象或函数内部却从外向内地指向了对象或函数本身，就像一条首尾相接的“衔尾蛇”，衔尾蛇既反映荣格所说的人类心理的&lt;strong&gt;原型&lt;/strong&gt;，又与道长神秘兮兮地说过的人类意识&lt;strong&gt;自指&lt;/strong&gt;的特性不谋而合，哈哈，又见心理学。&lt;/p&gt;</summary><category term="Javascript"></category></entry><entry><title>用sed与awk整理文件名</title><link href="http://defsniky.com/posts/2014-01-28-using-sed-and-awk-format-file-name.html" rel="alternate"></link><updated>2014-01-28T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-01-28:posts/2014-01-28-using-sed-and-awk-format-file-name.html</id><summary type="html">&lt;h3&gt;1. 需求&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将文件名统一整理成如下格式：&lt;/p&gt;
&lt;p&gt;1)文件名中只允许出现英文字母、数字以及短划线；&lt;/p&gt;
&lt;p&gt;2)年份开头，并以短划线连接文件名，如：2014-Title of File.pdf；&lt;/p&gt;
&lt;p&gt;3)四个字母及以上或短划线引导的单词首字母大写，出现其它符号如冒号、顿号等以空格代替。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搜集文献的时候为了尽快、更多地下载，往往不想费时间整理文件名，于是就会得到下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Raw file names" src="/theme/images/blog/raw_files.png" title="Raw files" /&gt;&lt;/p&gt;
&lt;p&gt;根据文题及发表时间重命名后，不同的出处的文档标题格式各异，且各种符号不一而足，因而需要按照需求统一格式，下面引入 sed 与 awk 的解决方案，&lt;code&gt;一行代码&lt;/code&gt;解决问题&lt;code&gt;*_*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Copy title" src="/theme/images/blog/copy_title.png" title="Copy original title" /&gt;&lt;/p&gt;
&lt;h3&gt;2. 解决方案&lt;/h3&gt;
&lt;p&gt;sed 与 awk 相关教程见此处：&lt;a href="http://coolshell.cn/articles/9070.html" title="awk"&gt;CoolShell&amp;gt;AWK 简明教程&lt;/a&gt;、&lt;a href="http://coolshell.cn/articles/9104.html" title="sed"&gt;CoolShell&amp;gt;sed 简明教程&lt;/a&gt;。由于文件名是单行文本，sed 只做单行文本的正则匹配与更改，即用到&lt;code&gt;'s/old/new/g;'&lt;/code&gt;将&lt;code&gt;old&lt;/code&gt;替换为&lt;code&gt;new&lt;/code&gt;，用于修改一些多余的符号包括空格、冒号等；awk 则是对输入流进行格式化处理，得到我们需求中规定的格式。&lt;/p&gt;
&lt;p&gt;sed 部分正则替换代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sed &lt;span class="s1"&gt;&amp;#39;s/[ ]*:[ ]*/-/g;&amp;#39;&lt;/span&gt;          &lt;span class="c"&gt;#冒号（包括两边空格）替换为短划线&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/\./=/g;&amp;#39;&lt;/span&gt;                 &lt;span class="c"&gt;#将点号临时替换为=&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/\(.*\)=/\1./g;&amp;#39;&lt;/span&gt;          &lt;span class="c"&gt;#将括号临时替换为=&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/[ ]*[+|?|_|,|;][ ]*/ /g;&amp;#39;&lt;/span&gt;    &lt;span class="c"&gt;#特殊符号替换为空格&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/=/ /g;&amp;#39;&lt;/span&gt;                  &lt;span class="c"&gt;#将临时=替换为空格&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/ \([0-9]\)/-\1/g;s/\([0-9]\) /\1-/g&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;#将数字间的空格替换为短划线&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;awk 按照首字母大写规则进行格式化输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#以短划线分割 对短划线引导的单词首字母大写&lt;/span&gt;
awk -F- &lt;span class="s1"&gt;&amp;#39;{for(i=1;i&amp;lt;=NF;i++){$i=tolower($i);sub(&amp;quot;.&amp;quot;,toupper(substr($i,1,1)),$i)}}1&amp;#39;&lt;/span&gt; &lt;span class="nv"&gt;OFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;-

&lt;span class="c"&gt;#四个字母以上单词首字母大写&lt;/span&gt;
awk &lt;span class="s1"&gt;&amp;#39;{for(i=1;i&amp;lt;=NF;i++){if(length($i)&amp;gt;3||i==1){sub(&amp;quot;.&amp;quot;,toupper(substr($i,1,1)),$i)}}}1&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以&lt;code&gt;pipe&lt;/code&gt;连接所有处理过程(&lt;a href="https://gist.github.com/sniky/6150585" title="Gist"&gt;gist&lt;/a&gt;)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;#Script name: Renamee.sh&lt;/span&gt;

mv &lt;span class="s2"&gt;&amp;quot;$1&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;`basename &amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;|sed &amp;#39;s/[ ]*:[ ]*/-/g;s/\./=/g;s/\(.*\)=/\1./g;s/[ ]*[+|?|_|,|;][ ]*/ /g;s/=/ /g;s/ \([0-9]\)/-\1/g;s/\([0-9]\) /\1-/g&amp;#39;|awk -F- &amp;#39;{for(i=1;i&amp;lt;=NF;i++){$i=tolower($i);sub(&amp;quot;&lt;/span&gt;.&lt;span class="s2"&gt;&amp;quot;,toupper(substr($i,1,1)),$i)}}1&amp;#39; OFS=-|awk &amp;#39;{for(i=1;i&amp;lt;=NF;i++){if(length($i)&amp;gt;3||i==1){sub(&amp;quot;&lt;/span&gt;.&lt;span class="s2"&gt;&amp;quot;,toupper(substr($i,1,1)),$i)}}}1&amp;#39;`&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如需批量操作可用&lt;a href="https://gist.github.com/sniky/8215756" title="Mapwalk.py"&gt;Mapwalk&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;3. 待改进&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以单词长度作为首字母大小写的判断仍不够智能，一些较长的介词仍会被误判而一些首字母缩写的单词（如 BOLD）则会被误杀；&lt;/li&gt;
&lt;li&gt;从 PDF 中直接解析年份与文题一直悬而未解，能找到合适的方法才可以真正完全自动化；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="Sed"></category><category term="Awk"></category><category term="FUN"></category></entry><entry><title>关于编码的一切</title><link href="http://defsniky.com/posts/2014-01-16-All-about-encoding.html" rel="alternate"></link><updated>2014-01-16T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-01-16:posts/2014-01-16-All-about-encoding.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;乱码&lt;/strong&gt;与&lt;strong&gt;时间格式&lt;/strong&gt;错误如同矗立在所有程序员面前的太行王屋两座大山。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编码错误或乱码几乎是每个人都会遇到的问题，比如用 Python 抓取网页进行正则分析之后发现在原来网页上正常的文字抓取下来之后变成乱码了，或者是存进 MySQL 之后变成乱码了，又或者本来在编辑器里面编辑得好好的输出之后又是乱码……要命的是每次遇到乱码问题，经过一番痛苦挣扎之后终于解决了，之后总是还会遇到新的乱码问题，这才是真正的“子子孙孙无穷尽也”，本文试图从头到尾将编码问题彻底阐述清楚，至少以后再次遇到&lt;code&gt;烫烫烫烫烫烫烫烫烫&lt;/code&gt;的问题能够有迹可循。&lt;/p&gt;
&lt;h3&gt;1. 什么是编码&lt;/h3&gt;
&lt;p&gt;中文 &lt;code&gt;雨&lt;/code&gt; 翻译成英文变为 &lt;code&gt;rain&lt;/code&gt; ，我们可以说是将中文这种以&lt;strong&gt;横竖撇捺&lt;/strong&gt;等简单笔画为基本元素的编码形式转换成了英文这种以 &lt;strong&gt;&lt;code&gt;a-z&lt;/code&gt;&lt;/strong&gt; 26个英文字母为基本元素的编码形式，同样在计算机的世界里面，一切事物都是由 0 和 1 这两个基本元素编码而成的，想象一下显示器上面所呈现出来的所有的精美绝伦的影像以及音响里传出的所有美妙乐章都源自于 0 和 1 这两个简单数字的复杂组合。&lt;/p&gt;
&lt;p&gt;编码问题从理论上来说也许并不复杂，只是从一种符号系统到另外一种符号系统之间的映射，但是在实际操作或者实施编码的过程中往往会出现很多问题(见第4部分)，我们需要将人类的意图翻译成机器能够理解的二进制编码，在计算机内部经过一系列的加工处理之后，又将这些二进制的信息重新编码成人类可以理解的自然语言（中文或者是英文甚至是图像、影音），对于英文来说，由于其语言构成的规律特性，只需要将其每一个元素（字母或简单符号）与二进制数进行一一对应，然后按照顺序排列就可以得到相应的单词、语句，因而简单的&lt;a href="http://zh.wikipedia.org/wiki/ASCII"&gt;ASCII编码系统&lt;/a&gt;已经足够应付，然而为了表示更多的语系或符号，我们就不得不 ASCII编码系统进行扩充，以容纳或者表示更多的语言符号，而乱码的问题也大多产生与此，接下来继续看一下计算机是如何对更多的语言符号进行编码的。&lt;/p&gt;
&lt;h3&gt;2. 如何编码&lt;/h3&gt;
&lt;p&gt;很巧的是编码格式与时间格式等问题以及许多计算机相关的问题都避免不了与&lt;strong&gt;格式&lt;/strong&gt;相关，统一的格式源自于相同的规则或者说标准(Standard)。ASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符(&lt;a href="http://zh.wikipedia.org/wiki/Ascii" title="wikipedia"&gt;Wiki&lt;/a&gt;)，在ASCII编码中每一个字符需要8位来表示，而8位一共可以编码&lt;code&gt;2**8 = 256&lt;/code&gt;个字符，这显然不足以将全世界各种不同语系、各种不同的符号涵盖在内，因而就需要将其进行扩展，也就是我们现在最常用的Unicode，现在 Unicode 仍然在不断增加，每次增加都会有新的字符被编码进来，Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符，每个字符占用2个字节，这样理论上一共最多可以表示&lt;code&gt;2**16 = 65536&lt;/code&gt;个字符，其中中文在Unicode表中所对应的二进制数字（转换成十六进制后）的范围是：&lt;code&gt;4E00 - 9FFF&lt;/code&gt;中日韩统一表意文字(CJK Unified Ideographs)。ASCII 与 Unicode 的编码方式就如同 C 语言中 &lt;code&gt;char&lt;/code&gt; 类型与 &lt;code&gt;int&lt;/code&gt; 类型的区别一样。&lt;/p&gt;
&lt;h3&gt;3. Unicode 与 UTF-8&lt;/h3&gt;
&lt;p&gt;Unicode是一种编码标准，比如说它规定汉字&lt;code&gt;雨&lt;/code&gt;对应的数字大小为&lt;code&gt;0x96e8&lt;/code&gt;（十进制38632），因而从本质上来说Unicode只是一张字符表(code table)，但是具体用什么方法来实现这种编码的转换，也有许多不同的选择，常见的UTF-8(8-bit Unicode Transformation Format)即是其中一种转换方法。(&lt;a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html#unicode"&gt;UTF-8 and Unicode FAQ&lt;/a&gt;)，其工作方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="UTF-8" src="/theme/images/blog/utf-8.png" title="UTF-8" /&gt;&lt;/p&gt;
&lt;h3&gt;4. 实现过程中的各个环节&lt;/h3&gt;
&lt;p&gt;字符从键盘输入到显示器显示出来，一般会经历下面几个过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="encoding-decoding-flow" src="/theme/images/blog/encoding-decoding-flow.png" title="Encoding-Decoding-FLow" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先是编码过程，这一过程与所用的&lt;strong&gt;编辑器&lt;/strong&gt;相关，以 vim 为例，当以 ASCII 的格式保存文件时，如果文件中含有 ASCII 字符之外的字符，则在保存的时候就会报错，因而需要将 vim 设置为 UTF-8 的编码格式（以UTF-8的方法保存、读取文件），方法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#file ~/.vimrc&lt;/span&gt;
&lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="nv"&gt;fileencoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;utf-8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大多数编辑器中出现乱码的问题多是由于保存格式的原因所导致，因此一般可以通过改变配置中的编码格式（如设为UTF-8）修复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对程序员来来说更关心的是在特定编程环境下，字符的编码是如何被加工处理的，下面就以 Python 2.7.5 为例加以解释。Python 2.x 中默认的编码格式为 ASCII：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;UTF-8的编码方式规定，Unicode范围由U+0800至U+FFFF的字符（如&lt;code&gt;雨&lt;/code&gt;）使用三个字节进行编码，其编码方式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;U+00000800 – U+0000FFFF &amp;lt;-&amp;gt; 1110xxxx 10xxxxxx 10xxxxxx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此一来，我们便知道会出现'\xe9\x9b\xa8'这种奇怪的乱码的原因是什么了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;rain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;雨&amp;#39;&lt;/span&gt;
rain
//Output &amp;gt;&amp;gt;&amp;gt; &lt;span class="s1"&gt;&amp;#39;\xe9\x9b\xa8&amp;#39;&lt;/span&gt;

rain.decode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
//Output &amp;gt;&amp;gt;&amp;gt; u&lt;span class="s1"&gt;&amp;#39;\u96e8&amp;#39;&lt;/span&gt;

rain.encode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
//Raise error:
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;    Traceback (most recent call last):&lt;/span&gt;
&lt;span class="s2"&gt;    File &amp;quot;&lt;/span&gt;&amp;lt;stdin&amp;gt;&lt;span class="s2"&gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;    UnicodeDecodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t decode byte 0xe9 in position 0: ordinal not in range(128)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现上面编码错误的原因还要从UTF-8的编码方法中找，UTF-8使用3个字节对&lt;code&gt;雨&lt;/code&gt;字进行编码，得到的Unicode码为应为'\u96e8'，而其对应的UTF-8数字却为'e99ba8'（见上面UTF-8的编码方式中的xxxx），而这三个字节在 ASCII 中则被表示为'\xe9\x9b\xa8'，因此这一编码重新以UTF-8进行解码&lt;code&gt;rain.decode('utf8')&lt;/code&gt;仍然可以得到正确的Unicode，但是在ASCII环境下进行UTF-8编码则会报错，因为已经超出了ASCII的编码范围。解决这一问题的方法就是设定默认的编码方式为UTF-8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="nb"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39;Python 运行时会检查环境设置并删除setdefaultencoding方法，因而需要reload(sys)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后一步是关于解码的过程，即将计算机存储的二进制数转换成屏幕上显示出来的各式各样的字符，这一过程中产生的乱码一方面可能是由于系统不支持对某些字体的渲染甚至对于较旧的系统不支持某些特殊字符的显示，另一方面仍然可能是所配置的编码格式的问题，尝试将编码格式设置为UTF-8或许解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文试图理清计算机中关于编码的一系列概念，如 ASCII、Unicode、UTF-8等，并试图从编码及解码的各个层面找出可能出现乱码的原因，为以后能够更快地定位乱码错误原因提供参考。&lt;/p&gt;</summary><category term="Encoding"></category><category term="Python"></category></entry><entry><title>你的密码是什么？</title><link href="http://defsniky.com/posts/2013-12-26-password-statistic.html" rel="alternate"></link><updated>2013-12-26T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-12-26:posts/2013-12-26-password-statistic.html</id><summary type="html">&lt;p&gt;收集了一些密码，做了简单的统计，发现一些比较有趣的现象&lt;code&gt;^_^&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="/projects/password/visu.html"&gt;What's your Passwords?&lt;/a&gt;&lt;/p&gt;</summary><category term="FUN"></category></entry><entry><title>图像处理的第一步：选择并抽取正确的特征</title><link href="http://defsniky.com/posts/2013-12-09-choose-and-extract-the-right-features.html" rel="alternate"></link><updated>2013-12-09T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-12-09:posts/2013-12-09-choose-and-extract-the-right-features.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;特征提取&lt;/strong&gt;是计算机视觉和图像处理中的一个概念...特征提取的结果是把图像上的点分为不同的子集，这些子集往往属于孤立的点、连续的曲线或者连续的区域(&lt;a href="http://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"&gt;Wiki&lt;/a&gt;)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上来说，图像处理任务首先都是要选取与任务相关的特征（如人脸识别中人脸的特征、边缘检测中边缘的特征等），然后将这些特征从复杂多变的背景信息中分离出来，再进行更进一步的处理。因而选择一个好的特征至关重要，后续的精细加工都是基于前面定位、过滤、抽取出来的较为单纯的特征信息，以图像中文字定位为例来说，常用的方法大致可以分为两种类型：基于连通域的方法和基于纹理的方法（脚注没修好，这里就不引用参考文献了），实际上就是针对于图像中的文字通常具有“在相对连续区域内颜色相同”以及“笔画之间夹杂细小缝隙的纹理或空间频率特征”。&lt;/p&gt;
&lt;p&gt;常用的图像特征有颜色特征、纹理特征、形状特征、空间关系特征等(&lt;a href="http://blog.sina.com.cn/s/blog_4e6680090100d2s9.html"&gt;Ref-1&lt;/a&gt;)。但是如何从这些特征中去选取最合适当前任务的特征呢？我们知道有一种“机器”在图像处理任务中做得非常出色，那就是人的视觉系统，David Marr 的经典著作 《&lt;em&gt;&lt;a href="http://book.douban.com/subject/5273663/"&gt;Vision&lt;/a&gt;&lt;/em&gt;》中也有提到，在最初人们想要用计算机去处理图像信息时并没有多少人想到这会有多难，毕竟对我们人类来说这些都是非常直觉、简单的加工过程，甚至在我们都还没有意识到的情况下视觉、认知系统已经完成了对图像的深度加工。而当人们真正着手去做的时候才发现，即使是最简单的 feature detector 要实现也是困难重重，在毫无头绪与经验的情况下所能采取的一种方法就是厚着脸皮不停尝试，正如 David Marr 所描述的 &lt;code&gt;unashamedly empirical approach :P&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还是以文字定位为例，基于连通域的方法关键在于让文字区域的颜色或灰度值能够与不同图像的背景分离开来，因此采用什么样的颜色空间、取多大的阈值分离背景、通过怎样的形态学变化填充、联通文字所在的区域就成了算法需要调整的关键参数（这只是我基于多次尝试、对比得出的结论，因而未必最优，也没有理论的基础）。首先是颜色空间的选择，在尝试了&lt;a href="http://zh.wikipedia.org/wiki/HSV%E8%89%B2%E5%BD%A9%E5%B1%9E%E6%80%A7%E6%A8%A1%E5%BC%8F"&gt;HSV&lt;/a&gt;、&lt;a href="http://zh.wikipedia.org/wiki/CMYK"&gt;CMYK&lt;/a&gt;等之后，最后转向了&lt;a href="http://zh.wikipedia.org/wiki/Lab%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"&gt;Lab色彩空间&lt;/a&gt;(&lt;a href="http://www.cnblogs.com/skyseraph/archive/2011/08/11/2135291.html"&gt;Ref-2&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;OpenCV-python codes&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;cv2&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;

&lt;span class="n"&gt;org&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;src&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cvtColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;COLOR_BGR2LAB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;src&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;waitKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;destroyAllWindows&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="处理结果" src="/theme/images/blog/sicp.png" title="处理结果" /&gt;&lt;/p&gt;
&lt;p&gt;Wiki 中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不像RGB和CMYK色彩空间，Lab颜色被设计来接近人类视觉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道这是不是巧合，但可以肯定的是即便如此 Lab颜色也不会适合所有的处理任务。接下来通过阈值化、形态学变化等进一步分离特征：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;randint&lt;/span&gt;

&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threshold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;157&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;THRESH_BINARY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;morphologyEx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MORPH_OPEN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getStructuringElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MORPH_RECT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;morphologyEx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MORPH_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getStructuringElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MORPH_RECT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="n"&gt;fc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hierarchy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;findContours&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;boundingRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="n"&gt;rectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="最终结果" src="/theme/images/blog/sicp_res.png" title="最终结果" /&gt;&lt;/p&gt;
&lt;p&gt;后面的阈值化等操作的分离效果很大程度上来说并不取决于参数的选取，尤其是考虑到不同的图像中文字颜色、尺寸及其与背景噪音的对比，能否将特征分离出来更多还是取决于颜色空间的选取。&lt;/p&gt;</summary><category term="OpenCV"></category><category term="Python"></category><category term="Vision"></category></entry><entry><title>Lisp初学之（二）: 线性递归 与 线性迭代</title><link href="http://defsniky.com/posts/2013-11-09-coral-reefs-of-the-lisp-world-2.html" rel="alternate"></link><updated>2013-11-09T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-11-09:posts/2013-11-09-coral-reefs-of-the-lisp-world-2.html</id><summary type="html">&lt;p&gt;&lt;code&gt;(TOPIC-ABOUT (COMP 'linear-recursive-process 'linear-iterative-process))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在学习使用其他语言时，迭代(iterative)或者循环是流程控制中非常重要的一个环节，但是与之功能类似递归(recursive)却往往不被提及或总是一带而过，原因大多是出于机器执行效率或消耗层面的考量，在这里我们抛开这些不去考虑，单纯从计算过程的角度出发去看 Lisp 中的迭代与递归（SICP &lt;a href="http://sniky.github.io/extra/sicp/book-Z-H-11.html#%_sec_1.2.1"&gt;1.2.1  Linear Recursion and Iteration&lt;/a&gt;），发现之前所理解的递归与迭代还是太肤浅，只是从语法形式层面判断“调用了自身”的是递归、&lt;code&gt;for/while/do&lt;/code&gt;的是循环迭代，结果就触礁了。&lt;/p&gt;
&lt;p&gt;仍然从考虑阶乘函数开始：
$$n! = n(n-1)(n-2)...1$$
用语言描述阶乘的定义为：当&lt;code&gt;n=1&lt;/code&gt;时，&lt;code&gt;n!=1&lt;/code&gt;；否则&lt;code&gt;n!=n*(n-1)!&lt;/code&gt;。很自然地，将定义转换成 Lisp 代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;fac&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fac&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;单从语法形式上(syntactic)看上面的代码，&lt;code&gt;(fac n)&lt;/code&gt;在定义时调用了它自身，这一语法形式上的事实我们称之为“递归过程(recursive procedure)”；而从实际的计算过程来看，也就是说看&lt;code&gt;(fac n)&lt;/code&gt;在实际执行的过程中做了那些计算，结果是只有当调用到&lt;code&gt;(fac 1)&lt;/code&gt;时才返回了明确的结果 1，在此之前，&lt;code&gt;(fac (- n 1))&lt;/code&gt;只是作为展开过程中的助记符，推进程序的前进，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="递归" src="http://sniky.github.io/extra/sicp/ch1-Z-G-7.gif" title="递归" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(fac n)&lt;/code&gt;产生了一个递归的计算过程(recursive process)，为了完成这一计算过程，它在形式上调用了自身，在计算过程中将自身作为推进（展开）计算的标识符，作为计算代价，我们不得不记住展开过程中所有&lt;code&gt;(fac (- n 1))&lt;/code&gt;经过的地方，直到&lt;code&gt;(fac 1)&lt;/code&gt;给出明确的返回值，再沿原路返回回去，得到&lt;code&gt;(fac n)&lt;/code&gt;的值；又因为阶乘计算过程中，我们所要记住的&lt;code&gt;(fac (- n 1))&lt;/code&gt;经过的路径与 n 的大小存在线性相关，因而称这样的计算过程为“&lt;span class='emp'&gt;线性递归过程(Linear Recursive Process)&lt;/span&gt;”。&lt;/p&gt;
&lt;p&gt;再考虑迭代的算法，所谓迭代，在计算阶乘的过程中可以看做是对 &lt;code&gt;n&lt;/code&gt; 与 &lt;code&gt;(n - 1)&lt;/code&gt; 的乘积在 &lt;code&gt;n = 1, 2, ..., n&lt;/code&gt; 的范围内重复、累积：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;fac-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;product&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;product&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;iter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的程序从语法形式上来看，仍然是一个递归的过程：&lt;code&gt;(iter i product)&lt;/code&gt; 内部调用了 &lt;code&gt;(iter (+ i 1) (* product i))&lt;/code&gt;，但是从实际的计算过程来看，我们不需要像递归计算那样记住整个递归过程的推进路线，而是通过迭代更新每次调用时所用的参数，这样计算过程中我们需要记住的只有迭代计数变量 &lt;code&gt;i&lt;/code&gt;、迭代乘积 &lt;code&gt;product&lt;/code&gt;、以及 &lt;code&gt;n&lt;/code&gt;；又因为阶乘计算过程中，所用的计算步骤或者所要记住的迭代变量的迭代次数与 n 的大小线性相关，因而称这样的计算过程为“&lt;span class="emp"&gt;线性迭代过程(Linear Iterative Process)&lt;/span&gt;”。这种用递归的过程实现的迭代的计算过程也称为&lt;span class="emp"&gt;尾递归&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总的来说，区分线性递归与尾递归、递归与迭代要从语法描述的过程与实际的计算过程去考虑。&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="SICP"></category><category term="Lisp"></category></entry><entry><title>SICP 英文第二版</title><link href="http://defsniky.com/posts/2013-10-28-sicp-online-with-reader-friendly-style.html" rel="alternate"></link><updated>2013-10-28T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-10-28:posts/2013-10-28-sicp-online-with-reader-friendly-style.html</id><summary type="html">&lt;p&gt;&lt;a href="/projects/sicp/book-Z-H-4.html"&gt;SICP full-text&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;this is a copy from &lt;a href="http://mitpress.mit.edu/sicp/"&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://creativecommons.org/licenses/by-nc/3.0/" title="licenses"&gt;&lt;img alt="licenses" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /&gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="SICP"></category></entry><entry><title>Lisp初学之（一）: APPLY 与 MAPCAR</title><link href="http://defsniky.com/posts/2013-10-22-coral-reefs-of-the-lisp-world-1.html" rel="alternate"></link><updated>2013-10-22T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-10-22:posts/2013-10-22-coral-reefs-of-the-lisp-world-1.html</id><summary type="html">&lt;p&gt;&lt;code&gt;(TOPIC-ABOUT ((COMP LIST CONS) (COMP APPLY MAPCAR)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于lisp的争论太多了，有人对其赞美到了无以复加的地步，也有人觉得不以为然，但是作为一个没有深入学习过的人来说，就只能做一个不明真相的围观群众。而对于那些跃跃欲试想要参与进来的初学者来说，想要入门却并非易事，一方面面对高手们扑面而来的那些玄之又玄的大道，另一方面还要面对lisp本身“奇异”的表达形式以及最致命的环环相扣的括号。因而选择一个合适的入门材料就显得更为重要&lt;a href="http://www.zhihu.com/question/19621539"&gt;&lt;strong&gt;&amp;rarr;&lt;/strong&gt;&lt;/a&gt;，有人推荐&lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;SICP&lt;/a&gt;等一些大部头著作，但是这些作为深入学习研究来说比较适合，如果作为熟悉语法特性等，还是直接动手开始coding比较合适，&lt;a href="https://github.com/google/lisp-koans"&gt;Common Lisp Koans&lt;/a&gt;就是一个很好的选择，这个项目模仿Ruby Koans通过填补代码来熟悉Lisp的语法及特性。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mapcar-and-reduce.lsp&lt;/code&gt;一节，用 apply 与 mapcar 实现转置矩阵的功能，在Lisp中函数也可以当做参数传递给其它函数使用，其中内置可以以函数作为参数的函数有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;funcall&lt;/span&gt; &lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapcar&lt;/span&gt; &lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;;(&lt;/span&gt;&lt;span class="n"&gt;NIL&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;NIL&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;NIL&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html"&gt;Funcall, Apply, and Mapcar&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;funcall&lt;/code&gt; 的第一个参数为执行函数（将第一个参数称为“执行函数”），剩余参数作为该函数的参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apply&lt;/code&gt; 与 &lt;code&gt;funcall&lt;/code&gt; 的作用一样，只是其最后一个参数必须为list；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapcar&lt;/code&gt; 接受第一个参数作为执行函数，然后将第二个list中的每一个参数依次传递给执行函数，并将执行结果依次合并为一个list输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;奇怪的是 &lt;code&gt;apply&lt;/code&gt; 与 &lt;code&gt;funcall&lt;/code&gt; 之间的区别仅仅是 &lt;code&gt;apply&lt;/code&gt; 的参数必须是 &lt;code&gt;list&lt;/code&gt;，那么 &lt;code&gt;apply&lt;/code&gt; 的功能是&lt;a href="http://blog.csdn.net/ryuali2010/article/details/7816559"&gt;如何实现&lt;/a&gt;的？&lt;/p&gt;
&lt;p&gt;原来 &lt;code&gt;apply&lt;/code&gt; 先对执行函数以外参数调用 &lt;code&gt;list*&lt;/code&gt; 方法，然后再对生成的列表调用 &lt;code&gt;values-list&lt;/code&gt; 方法，最终再将 &lt;code&gt;values-list&lt;/code&gt; 输出的结果依次传入执行函数中。这里 (&lt;code&gt;list* args&lt;/code&gt;) 的执行过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 args 是 list 类型，则返回 args;&lt;/li&gt;
&lt;li&gt;如果 args 是单个数字，则返回 args;&lt;/li&gt;
&lt;li&gt;如果 args 是多个元素（非 list 形式），则将倒数第二个元素与最后一个元素以 dot-list 的形式结合并返回整个列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里又涉及到&lt;a href="https://acl.readthedocs.org/en/latest/zhCN/ch3-cn.html"&gt;点状列表&lt;/a&gt;（Dotted Lists）的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;调用 list 所构造的列表，这种列表精确地说称之为正规列表(properlist )。
一个正规列表可以是 NIL 或是 cdr 是正规列表的 Cons 对象…一个非正规列表的 Cons 对象称之为点状列表 (dotted list)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，&lt;code&gt;list*&lt;/code&gt; 的作用主要在最后一个参数上，它将最后一个元素以 &lt;code&gt;append&lt;/code&gt; 的方式连接到前面的元素所组成的列表中（这样做的意义待考？），而 &lt;code&gt;values-list&lt;/code&gt;执行的操作则是将参数列表中的每一个元素依次返回，但传入参数不能是dot-list，这就导致了 &lt;code&gt;apply&lt;/code&gt; 的最后一个参数必须是 &lt;code&gt;list&lt;/code&gt; 类型的特性（这样做的意义也待考？）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 与 &lt;code&gt;mapcar&lt;/code&gt; 的组合如何完成转置矩阵的功能呢？还要依赖于 Lisp 函数参数的参数列表（Parameter Lists）机制，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;形参中的 &amp;amp;rest 关键词收集所有剩余参数，并存放到一个列表里&lt;code&gt;(list r)&lt;/code&gt;。将 mapcar 与上面的匿名函数相结合会得到什么样的结果呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapcar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapcar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的方法已经得到了转置的效果，mapcar 将后续列表中的元素逐一传入匿名函数，而匿名函数通过 &amp;amp;rest 接收多余的参数，这样就可以无限制地添加参数，而通过 mapcar 遍历每个参数列表的元素，经由匿名函数&lt;code&gt;(list r)&lt;/code&gt;组装后返回，从而实现转置的效果。而 apply 的作用则是利用 list* 与 values-list 将矩阵的每一行作为输入列表依次传递给上面的过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;mapcar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lisp Koans 很适合学习，实际上有人整理了一个 Koans 系列：&lt;a href="http://www.lauradhamilton.com/learn-a-new-programming-language-today-with-koans"&gt;Learn a New Programming Language Today with Koans&lt;/a&gt;，涵盖了许多编程语言。另外，关于 Lisp，有一篇&lt;a href="http://www.defmacro.org/ramblings/lisp.html"&gt;The Nature of Lisp&lt;/a&gt;（翻译版：&lt;a href="http://www.csdn.net/article/2012-11-22/2812113-The-Nature-Of-Lisp"&gt;Lisp的本质&lt;/a&gt;）很值得初学者拜读。&lt;/p&gt;</summary><category term="Lisp"></category><category term="SICP"></category></entry><entry><title>Bash不是外星语</title><link href="http://defsniky.com/posts/2013-08-01-Bash-is-not-an-alien-language.html" rel="alternate"></link><updated>2013-08-01T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-08-01:posts/2013-08-01-Bash-is-not-an-alien-language.html</id><summary type="html">&lt;p&gt;bash 看起来一直都像一门外星语，因为从一开始接触到它的时候，它看起来更像是操作系统的化身而不是一门编程语言，而且事实上这样凭直觉的理解并没有什么错，因为大部分情况下用到bash的目的都是为了与操作系统进行交流。&lt;/p&gt;
&lt;!--
bash script容易令人疑惑的地方除了与操作系统之间千丝万缕的关系（包括环境变量等），像`if...fi`这样拗口的语法看起来也很像外星语，还有一点比较重要的是用户容易觉得bash script其实就是一堆command line的堆砌（虽然这样认为也没错），所以只要掌握特定用途的command就ok了。这里的`用户`指的就是我自己，正因为这些原因，平日里拿到别人写好的script就直接执行，作批量测试的时候大多数情况用python，“成功”地避开一行一行研究外星语一样的bash script也照样侥幸活到现在~

当然随着时间的推移，会慢慢发现一门语言的语法虽然是其可见的最鲜明的特征，但从某种（学习的）角度来说，它却是最不要紧的因素。
--&gt;

&lt;p&gt;比较经常会用到bash script的场景除了把简单堆砌的command写进一个脚本然后丢进可执行的目录下方便使用外，大多数情况下是进行一些批量执行或测试，或者是一些自动化执行过程。以前都是用python来代替，甚至觉得&lt;code&gt;os.system(cmd)&lt;/code&gt;这样的调用也能满足绝大部分需求，最近以来一是由于很多configure过程报错被逼着不得不去找出错误的原因，另一方面也是由于实在受够了python的&lt;code&gt;os.walk()&lt;/code&gt;了，所以从头开始再学习一次bash这门不是外星语的外星语。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Intro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Shell本身是一种用C语言编写的程序，常见的Shell种类众多，从本质上说bash并没有什么特别，但它是大多数linux系统默认的shell，即使用户不用也会有许多os后台程序在让它不停地奔跑，所以不用也是浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境变量&lt;/strong&gt;
bash中的变量，既可以被bash本身所应用，而更常见的是作为环境变量存在。常见遵循如下几种规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;123 &lt;span class="c"&gt;# &amp;#39;=&amp;#39; 左右两侧均不可有空格，变量值为单个字串(不含空白字符)则可省略引号；&lt;/span&gt;
&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello world!&amp;#39;&lt;/span&gt; NOT &lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;# 双引号与单引号不同；&lt;/span&gt;
&lt;span class="nb"&gt;echo &lt;/span&gt;hello &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;world! &lt;span class="c"&gt;# &amp;#39;${VAR_NAME}&amp;#39;中&amp;#39;{}&amp;#39;用于消除变量名的边界歧义；&lt;/span&gt;
&lt;span class="nb"&gt;export &lt;/span&gt;PATH; &lt;span class="nb"&gt;unset &lt;/span&gt;PATH &lt;span class="c"&gt;# export &amp;amp; unset 将变量输出(销毁)至环境变量；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，第2条，bash引用变量所储存的内容用到特殊符号$，$var被称为变量扩展(variable expansion)，有点像C语言中指针的含义，而在bash中双引号会保留扩展的特性，而单引号则会将特殊字符当做普通字符来看待，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;rainy
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello $var.&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 输出 hello $var.&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello $var.&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;# 输出 hello rainy.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bash中另外一类变量是当执行脚本时从命令行中读取的参数(c语言中的&lt;code&gt;int argc, char* argv[]&lt;/code&gt;)，&lt;code&gt;$0, $1, $2, …, $#, $@&lt;/code&gt;，其中类比关系如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$# ~= int argc; $@ ~= argv[]; $i ~= argv[i]; $* ~= argv[1:]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串截取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bash中对(字符串)变量的截取是非常常见的操作，常见操作如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;abcdefghijklmnopqrstuvwxyz
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;3&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;#abc&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;0&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;#a-z&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;3&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;#d-z&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;${#&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="p"&gt;-3&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;#xyz - ${#var} is the len of $var.&lt;/span&gt;
&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;fofoofooobar
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;#\*fo&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# foofooobar 返回从左侧开始匹配&amp;#39;\*fo&amp;#39;最小位置之后的字符串；&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;##\*fo&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# oobar 返回从左侧开始匹配&amp;#39;\*fo&amp;#39;最大位置之后的字符串；&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;%foo\*&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# fofoo 返回从右侧开始匹配&amp;#39;fo\*&amp;#39;最小位置之前的字符串；&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="p"&gt;%%foo\*&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# fo 返回从右侧开始匹配&amp;#39;foo\*&amp;#39;最大位置之前的字符串；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;流程控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IF:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; condition &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c"&gt;# whitespace不能省；&lt;/span&gt;
&lt;span class="k"&gt;then &lt;/span&gt;
&lt;span class="k"&gt;    &lt;/span&gt;action
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; conditin2 &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="k"&gt;    &lt;/span&gt;action2
    .
&lt;span class="k"&gt;else &lt;/span&gt;actionx
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;% endhighlight %&lt;span class="o"&gt;}&lt;/span&gt;
* FOR:
&lt;span class="o"&gt;{&lt;/span&gt;% highlight bash linenos%&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;for &lt;/span&gt;arg in &lt;span class="nv"&gt;$@&lt;/span&gt;;&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$arg&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="Bash"></category></entry><entry><title>BP神经网络实践 - 代码识别器</title><link href="http://defsniky.com/posts/2013-06-23-Practice-for-BP-network.html" rel="alternate"></link><updated>2013-06-23T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-06-23:posts/2013-06-23-Practice-for-BP-network.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/linux/other/l-neural/index.html"&gt;神经网络介绍&lt;/a&gt;一文介绍了用神经网络算法进行代码识别的方法，即:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设给出 500 个字符的代码段，您知道它们是 C、C++、Java 或者 Python。现在构造一个程序，来识别编写这段代码的语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所用代码来自：&lt;a href="http://gnosis.cx/download/neural_net_1.zip"&gt;代码识别&lt;/a&gt;，主要实现一个神经网络&lt;a href="https://github.com/sniky/A-N-N/blob/master/bp_net_code_recognizer/bpnn.py"&gt;NN&lt;/a&gt;，于是从 github 上分别抓取了C、Java、Python的代码，来做一下测试，其中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言：1759个文件，Java：3333个文件，Python：1909个文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先统计分析代码中20个特殊字符出现的频率，作为输入节点(&lt;a href="https://github.com/sniky/A-N-N/blob/master/bp_net_code_recognizer/statistic.py"&gt;统计代码见这里&lt;/a&gt;)，并重载了test方法，输出测试准确率：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testPat&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;cor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;testPat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;CORR&amp;quot;&lt;/span&gt;
                &lt;span class="n"&gt;cor&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;INCORR&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Output -&amp;gt; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Test result: &lt;/span&gt;&lt;span class="si"&gt;%.2f%%&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testPat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过调整&lt;code&gt;TRAIN_SIZE&lt;/code&gt;、&lt;code&gt;TEST_SIZE&lt;/code&gt;从&lt;a href="https://github.com/sniky/A-N-N/tree/master/bp_net_code_recognizer/dataSet"&gt;dataSet&lt;/a&gt;下的统计结果中抽取一定数量的数据作为训练和测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TRAIN_SIZE = 20, TEST_SIZE = 600&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;迭代次数为8000，最终训练差误收敛至&lt;span style="color:red"&gt;0.046145&lt;/span&gt;，测试准确率为&lt;span style="color:green"&gt;88.50%&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TRAIN_SIZE = 10, TEST_SIZE = 600&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;最终训练差误收敛至&lt;span style="color:red"&gt;0.016267&lt;/span&gt;，测试准确率为&lt;span style="color:green"&gt;85.83%&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TRAIN_SIZE = 50, TEST_SIZE = 600&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;最终训练差误收敛至&lt;span style="color:red"&gt;2.203505&lt;/span&gt;，测试准确率为&lt;span style="color:green"&gt;65.44%&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TRAIN_SIZE = 10, TEST_SIZE = 1200&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;最终训练差误收敛至&lt;span style="color:red"&gt;0.015848&lt;/span&gt;，测试准确率为&lt;span style="color:green"&gt;85.97%&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从测试结果来看，训练数量越小，误差可以收敛到越小；增加测试数量，也可以提高最终准确率。或者说所选取的特征能否作为甄别、分类的有效指标，也需要做预先的判别。&lt;/p&gt;</summary><category term="ANN"></category><category term="BP"></category><category term="ML"></category></entry><entry><title>C语言PHP扩展模板引擎Blitz加入FOREACH特性</title><link href="http://defsniky.com/posts/2013-05-28-Blitz-template-engine-added-foreach-statement.html" rel="alternate"></link><updated>2013-05-28T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-05-28:posts/2013-05-28-Blitz-template-engine-added-foreach-statement.html</id><summary type="html">&lt;p&gt;常用的PHP模板引擎（如&lt;a href="http://www.smarty.net/"&gt;Smarty&lt;/a&gt;）大多为PHP写成，而PHP的执行效率较低；C语言开发的PHP扩展用作模板引擎效率可以得到显著提升，&lt;a href="http://alexeyrybak.com/blitz/blitz_en.html"&gt;Blitz&lt;/a&gt;就是一个C语言开发的PHP模板引擎扩展，废话不多，先做一个简单的测试（测试代码在&lt;a href="https://github.com/sniky/Blitz-featured/blob/master/benchmark/index.php"&gt;这里&lt;/a&gt;）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nv"&gt;$alpha&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="nv"&gt;$nameStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;$j&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt; &lt;span class="nv"&gt;$j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="nv"&gt;$nameStr&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="nv"&gt;$alpha&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nb"&gt;array_push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$nameStr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;构建一个长为1000的简单字符串数组&lt;code&gt;$list&lt;/code&gt;，字符串长5~7，然后将数组assign到模板引擎里，比较运行时间：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;blitz_render&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;Global&lt;/span&gt; &lt;span class="nv"&gt;$list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nv"&gt;$View&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Blitz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;index.blz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$View&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Blitz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;list&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;$list&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;smarty_render&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;Global&lt;/span&gt; &lt;span class="nv"&gt;$list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;require&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/usr/lib/php/Smarty/Smarty.class.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$smarty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Smarty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nv"&gt;$smarty&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Smarty&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;list&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;$list&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="nv"&gt;$smarty&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;index.tpl&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;microtime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;blitz_render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nv"&gt;$t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;microtime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;smarty_render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nv"&gt;$t3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;microtime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Blitz used: &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;$t2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ms&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Smarty used: &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;$t3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;$t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ms&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;选取几次比较结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Blitz used: 1.6891956329346ms
Smarty used: 13.232946395874ms

Blitz used: 3.6599636077881ms
Smarty used: 18.430948257446ms
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;误差应该主要来源于虚构的数组&lt;code&gt;$list&lt;/code&gt;字符串长度随机，将数组长度降为10再比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Blitz used: 0.27894973754883ms
Smarty used: 11.041879653931ms

Blitz used: 0.52690505981445ms
Smarty used: 11.965036392212ms
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如此，大概就不需要进行显著性检验了。&lt;/p&gt;
&lt;p&gt;另，原本的Blitz中不支持for或者foreach循环，取而代之的是block进行遍历、迭代数组，但传入模板引擎的变量必须在PHP代码中格式化成嵌套数组的形式，这对于对于简单的数组（如上例中的一维数组）是很不方便的，将其稍加改动，在Blitz中加入foreach的属性(&lt;a href="https://github.com/sniky/Blitz-featured"&gt;这里&lt;/a&gt;)。实际上Blitz(v0.8.6)设计已经相当完善，改动内容一共也只有十几行，并没有对原本结构有所改动，但是阅读6000+行C源码，理清其错综复杂的数据结构、函数调用以及神出鬼没的指针传递的确不是件容易的事。&lt;/p&gt;
&lt;p&gt;最后，Blitz或者说C扩展确实快，其速度相当于C vs PHP，其缺点也恰恰相当于PHP vs C，无论PHP设计好与坏，开发PHP程序显然要比开发C更快速，因为它基于（集成于）C但更灵活，所以Smarty等PHP程序相较于C扩展也是类似的道理，速度'稍慢'，但灵活度更高，只在取舍。&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="PHP"></category><category term="C"></category></entry><entry><title>PHP与Python实现Hash比较（一）</title><link href="http://defsniky.com/posts/2013-05-18-Hash-implementation-in-PHP-vs-Python-part-1.html" rel="alternate"></link><updated>2013-05-18T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-05-18:posts/2013-05-18-Hash-implementation-in-PHP-vs-Python-part-1.html</id><summary type="html">&lt;p&gt;PHP中的array，python中的dict都是通过hash表(哈希表或散列表)实现的，或者说array与dict本身就是hash结构，本文及后续文章将分别比较PHP与python源代码中对哈希表的实现算法，一来学习其设计思想，另外可用于避免开发过程中一些可能会降低效率或易引发bug的操作。&lt;/p&gt;
&lt;p&gt;先来PHP。一切源于PHP的内置数据类型zval(见&lt;a href="http://lxr.php.net/xref/PHP_5_4/Zend/zend.h"&gt;PHP_X_X/Zend/zend.h&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;_zvalue_value&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;lval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;//long value&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;//double value&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HashTable&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;//hash table value&lt;/span&gt;
    &lt;span class="n"&gt;zend_object_value&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;zvalue_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_zval_struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//Variable information&lt;/span&gt;
    &lt;span class="n"&gt;zvalue_value&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;//value&lt;/span&gt;
    &lt;span class="n"&gt;zend_uint&lt;/span&gt; &lt;span class="n"&gt;refcount_gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;zend_uchar&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//active type&lt;/span&gt;
    &lt;span class="n"&gt;zend_uchar&lt;/span&gt; &lt;span class="n"&gt;is_ref_gc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中HashTable *ht即是PHP中用于表示Array类型的结构，在深究HashTable结构之前先了解哈希表的原理，在C语言中数组是通过自然数作为数组索引来存储数据的，而在PHP或python等这些语言中，哈希表是以key - value的方式存取的，要实现这一存储方式，则需要将任意可能的key对应或映射到数组或者内存的自然数序列索引上，即实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;index = hash(key)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;hash()即为哈希函数。理想状态下的hash()可以将任意的key映射到均匀分布且不重叠的自然数集合中，但由于key的不确定性，这显然是不可能的，因而一个好的哈希函数应该可以尽可能地避免重叠或碰撞(collisions)，而在PHP中实现这一功能的哈希函数采纳的是DJBX33A算法。源码中实现代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="nf"&gt;zend_inline_hash_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5381&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="cm"&gt;/* variant with the hash unrolled eight times */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* fallthrough... */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;: &lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;: &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;EMPTY_SWITCH_DEFAULT_CASE&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;据其注释中所解释的来看，DJBX33A (Daniel J. Bernstein, Times 33 with Addition)算法可简单描述为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hash(i) = hash(i-1) * 33 + str[i]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为何取33而不是其它数，解释说是对1 ~ 256进行分别进行测试后择优选择的结果，并没有理论上的支撑，而且初始的hash值为5381应该也没有什么特别特别的特别之处吧？到这里为止，首先可以确定的一条规则就是，&lt;span style="color: #3498db"&gt;在PHP中定义使用数组时key的长度以最好不要超过7为妙&lt;/span&gt;，便可省掉第一步的for循环，因而在考虑效率的前提下，道长当年所说的为了增加代码的可读性将变量名定为几十个字符甚至一句话显然是不可取的咯:P&lt;/p&gt;
&lt;p&gt;通过巧妙的算法，hash碰撞得以减少，但是并没有完全避免(例如：&lt;a href="http://blog.codinglabs.org/articles/hash-collisions-attack-on-php.html"&gt;PHP哈希表碰撞攻击原理&lt;/a&gt;），既然冲突是不可避免的，那就只能想办法解决冲突，算法书里面对冲突的处理方案有很多，PHP采用的是&lt;a href="http://www.nowamagic.net/academy/detail/3008060g"&gt;拉链法&lt;/a&gt;，具体实现方法还是要先追寻其定义(见&lt;a href="http://lxr.php.net/xref/PHP_5_4/Zend/zend_hash.h"&gt;PHP_X_X/Zend/zend_hash.h&lt;/a&gt;)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;//Used for numeric indexing&lt;/span&gt;
    &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pDataPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pListNext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pListLast&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pLast&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Bucket&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_hashtable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nTableSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nTableMask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nNumOfElements&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="n"&gt;nNextFreeElement&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInternalPointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//Used for element traversal&lt;/span&gt;
    &lt;span class="n"&gt;Bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pListHead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pListTail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Bucket&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;arBuckets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;dtor_func_t&lt;/span&gt; &lt;span class="n"&gt;pDestructor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;zend_bool&lt;/span&gt; &lt;span class="n"&gt;persistent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;nApplyCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;zend_bool&lt;/span&gt; &lt;span class="n"&gt;bApplyProtection&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;#if ZEND_DEBUG&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inconsistent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;HashTable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最终hash表的key保存在Bucket.arKey，key长为Bucket.nKeyLength，哈希函数计算得到的哈希值存为Bucket.h，当冲突时通过引出一条静态链表来解决，其实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ZEND_API&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;zend_hash_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;HashTable&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ulong&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;nIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Bucket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;IS_CONSISTENT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zend_inline_hash_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;nIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nTableMask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;arBuckets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nIndex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;arKey&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nKeyLength&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
            &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;memcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nKeyLength&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pNext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;p = p-&amp;gt;pNext即在已有元素之上开辟出新的位置存储冲突的下一个元素。至此，PHP中HashTable实现的基本思想就介绍完了，有空再把python的部分补上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建动态结构体的小trick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bucket结构体的最后一个元素arKey被定义为char *arKey;也有看到char arKey[1]，有人解释说利用变长结构体，加上有看到注释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;char arKey[1]; /* Must be last element */&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更是如坠云里雾里，还以为说 arKey 必须存放 HashTable 里面 key 字符串的最后一个字符…经过一番挣扎，发现原来不是这个意思，shit！(见&lt;a href="http://stackoverflow.com/questions/599365/what-is-your-favorite-c-programming-trick"&gt;what-is-your-favorite-c-programming-trick&lt;/a&gt;)，所谓的变长结构体只是说在考虑到内存连续性条件下，为了实现结构体内部元素的动态分配，利用struct的性质，将需要动态分配的变量放在结构体最后，如此以来通过malloc动态分配给struct的内存超出结构体本身所需的部分&lt;code&gt;sizeof(struct)&lt;/code&gt;可以顺其自然地被最后一个元素所访问，从而实现了可变长的结构体，所以说，注释中的&lt;em&gt;Must be last element&lt;/em&gt;不是说存放的是key的最后一个字符，而是必须放在结构体的最后一个元素！shit again(but a good trick:P)!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.nowamagic.net/academy/detail/1201011"&gt;PHP哈希表结构的深入剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="PHP"></category><category term="Python"></category></entry></feed>