<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>rainy</title><link href="http://defsniky.com/" rel="alternate"></link><link href="http://defsniky.com/feeds/xue-xi.atom.xml" rel="self"></link><id>http://defsniky.com/</id><updated>2014-07-15T00:00:00+08:00</updated><entry><title>马克飞象 + Evernote</title><link href="http://defsniky.com/posts/2014-07-15-keep-notes-with-maxiang.html" rel="alternate"></link><updated>2014-07-15T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-07-15:posts/2014-07-15-keep-notes-with-maxiang.html</id><summary type="html">&lt;p&gt;很多人都有记笔记的习惯，很多人也都有不停尝试各种软件、硬件试图找出一款用起来最舒心的笔记本的习惯，甚至不惜花费大量时间比较来、比较去，结果做选择的时间比真正拿来记笔记的时间还要多，而且不停地换来换去导致笔记大量流失。好吧，说的就是我&lt;code&gt;-_-!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OneNote  VS  Evernote&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很早之前就接触过微软的 OneNote ，一直以来 OneNote 都是我最喜欢的笔记软件，因为只有它用起来最像是在真正的笔记本上记录一样，所有的内容可以随处放置，落笔之处即可记录，而不需要像写 Word 文档一样规规矩矩地从上到下一行一行地写。当然其缺点也是由于有点过于拘泥于实体笔记本的模式了，缺少了 Tag、分类等归类整理的功能，随着笔记数量的增加负担会越来越重，当然最终让我不得不放弃它的原因主要还是在于内存吃得太多，运行不够流畅，想要等它优化升级，以微软的执行效率，估计还是等我攒钱加大内存来解决这个问题会更快一点吧...&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/onenote.png" data-title="OneNote" data-lightbox="example-set"&gt;
&lt;img alt="OneNote" src="/images/onenote.png" /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 Evernote 不可能没有用过，标签管理啊、跨终端啊、云存储啊等等的噱头其实在一开始的使用过程中都会觉得有些华而不实，因为说实话会在手机或者iPad上做笔记的情况真的是少之又少，而且刚开始线上同步的速度实在是不能忍，好在后来在大天朝地区另辟了印象笔记的服务器，速度跟稳定性总算有保障了。但是用起来还是觉得不爽因为排版实在是不行，用起来简直就是加强版的记事本而已，因此中间反反复复尝试了很多次也都没有坚持下来。最后重新回到 Evernote 竟然是因为它的一款插件性质的 Web App：&lt;a href="http://maxiang.info"&gt;马克飞象&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/maxiang.png" data-title="Evernote" data-lightbox="example-set"&gt;
&lt;img alt="Evernote" src="/images/maxiang.png" /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;马克飞象虽然名字有点虎但是确实是一款利器，Markdown 语言的加入瞬间让排版变成一件令人愉快的事情，更不用说能够会心一击戳中所有程序猿死穴的&lt;code&gt;Syntax Highlight&lt;/code&gt;功能，再加上 $LaTex$ 的数学公式编辑能力，简直让人毫无招架之力，分分钟跪地求饶：&lt;strong&gt;shut up and take my money!&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这边好久没有更新不只是因为变懒了，也是因为平日里整理的笔记都丢在 Evernote 里面（诶，这个借口不错！），因为不需要重新排版可以直接把笔记页面共享出来，下面会整理一些已完成的部分共享出来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;a href="https://app.yinxiang.com/shard/s40/sh/eccd8174-70d9-4fad-bf7b-002bdcca5ca2/7ecb9d59cf7a9a799f750fdd161b0a04"&gt;Pomelo Server &amp;amp; Client&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;a href="https://app.yinxiang.com/shard/s40/sh/a072159e-95b1-4388-8739-354c3cffb0f9/a120dc919f8abb08182ec0012a78c672"&gt;MySQL Notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;a href="https://app.yinxiang.com/shard/s40/sh/46b9c484-1183-4979-9203-e58402fdbfb4/7f54b20f71d9e65fa05e0b1e5ad430b0"&gt;Learn Python in Y Mins&lt;/a&gt;&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="Notes"></category></entry><entry><title>LDA 概率统计基础（一）</title><link href="http://defsniky.com/posts/2014-05-21-math-and-statistics-relearning-part-1.html" rel="alternate"></link><updated>2014-05-21T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-05-21:posts/2014-05-21-math-and-statistics-relearning-part-1.html</id><summary type="html">&lt;p&gt;之前(&lt;a href="/posts/2014-05-14-Why-using-SVM-in-scene-categorization-always.html"&gt;Why SVM&lt;/a&gt;)整理的几篇关于场景识别的计算模型，其中一个是Bayesian Hierarchical Model，还有就是最近比较热门的LDA(Latent Dirichlet Allocation)主题模型。LDA首先由Blei, David M.，Ng, Andrew Y.和Jordan, Michael I于2003年提出，比较成熟地应用于文本挖掘、文本主题识别等领域，后来被引入到图像场景识别中，包括Li Fei-Fei教授的Bayesian Hierarchical Model其实也是应用的LDA模型，但又因为LDA本身就是一个三层贝叶斯模型(three-level hierarchical Bayesian model)，只不过在具体应用过程中还有所不同，后面详细描述几个模型的时候将会提到。&lt;/p&gt;
&lt;p&gt;总而言之一句话，LDA模型很重要，但是涉及到很多概率统计的东西，仔细一看才发现，以前学过的基本已经忘得差不多了，只好恶补一下，网上有很多介绍LDA的文章，但是良莠不齐，抄袭者、昏昏者居多，但是&lt;a href="http://cos.name/author/rickjin/"&gt;rickjin&lt;/a&gt;大牛发表在&lt;a href="http://cos.name/author/rickjin/"&gt;统计之都&lt;/a&gt;的一系列文章绝对值得细细拜读。&lt;/p&gt;
&lt;p&gt;下面的内容将会是结合rickjin的文章以及重新学习整理过的一些知识点有助于学习、理解LDA模型：&lt;/p&gt;
&lt;h3&gt;1. 伯努利实验与二项分布&lt;/h3&gt;
&lt;p&gt;伯努利试验就是著名的抛硬币实验，抛一次硬币得到正面的概率为 $p$，得到反面的概率为 $q = 1 - p$；而二项分布(Binomial)就是 $n$ 次独立的伯努利试验中成功(得到正面)次数的分布 $X \sim B(n, p)$：$$P(k;n,p) = C^n_k p^k (1-p)^{n-k}$$&lt;/p&gt;
&lt;h3&gt;2. 多项式分布(Multinomial distribution)&lt;/h3&gt;
&lt;p&gt;将二项分布进行扩展，如果抛的不是只有两面的硬币，而是一个有 $k$ 个面的骰子，相互独立地抛 $N$ 次，那么数字 $i$ 出现的次数 $K_i$ 服从多项式分布；假设出现数字 $i$ 的概率为 $p_i$ ，则满足 $(p_1 + p_2 + ... + p_k) = \sum{p_i} = 1$，将 $N$ 次独立抽样看作是从 $N$ 次多项式全部展开后取其中 $i$ (概率为 $p_i$ )出现次数为 $K_i$的概率：
$$(p_1 + p_2 + ... + p_k) (p_1 + p_2 + ... + p_k) ... = (p_1 + p_2 + ... + p_k)^N = 1$$
那么数字 $i$ 出现 $K_i$ 的次数满足：
$$P( \vec{K};N, \vec{p} ) =   \frac{n!}{K_i!K_2!...K_k!}  p^{K_1}p^{K_2}...p^{K_k}$$
在主题模型中，假设文档 $D$ 中的所有词语 $\vec{W}=(w_1, w_2,..., w_N)$ 就是从 $k$ 个 topic 中进行了 $N$ 次独立取样得到的，那么从 $k$ 个 topic 中生成 $N$ 个词语，其中词语 $w_i$ 出现了 $k_i$ 次(即得到 $\vec{W}$ )的概率服从多项式分布。&lt;/p&gt;
&lt;h3&gt;3. 贝叶斯概率论&lt;/h3&gt;
&lt;p&gt;前面提到 LDA 是一个三层贝叶斯模型而不是简单的多项式分布，因此不得不提贝叶斯学派的概率理论。经典学派的观点认为概率是&lt;strong&gt;大量重复实验频率的稳定值&lt;/strong&gt;，因此也称作频率派；而贝叶斯学派赞成&lt;strong&gt;主观概率&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;People apparently want statistics to tell them the probability of their hypothesis being right. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如在抛硬币实验中我们不应该只考虑最终客观的统计频率，还要将我们对骰子本身特性的先验知识考虑在内。假设随机变量 $X \sim f(X, \theta)$ ，频率派将 $X$ 当做可重复实验的随机变量，而 $\theta$ 当做是概率分布中&lt;strong&gt;确定但未知&lt;/strong&gt;的参数，因此 $f(X, \theta)$ 反应的是 $X$ 的规律特性，$\theta$ 是可以通过对 $X$ 的抽样进行估计的。但是在贝叶斯派的观点中，未知的参数 $\theta$ 并&lt;strong&gt;不是确定的&lt;/strong&gt;，它自身服从自己的先验概率分布：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在贝叶斯学派看来，一切参数都是随机变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而贝叶斯的基本公式是：
$$P(H|D)  \propto  P(H) P(D|H)$$
也就是说我们最终观察到的&lt;strong&gt;后验概率&lt;/strong&gt; $P(H|D)$ 是由我们对假设 $H$ 本身的&lt;strong&gt;先验知识&lt;/strong&gt; $P(H)$ 与在先验知识的基础上观察得到的新数据即&lt;strong&gt;相似度&lt;/strong&gt; $P(D|H)$ 决定的；接下来问题就来了，对于先验知识，我们并不总是能够准确地知道其遵循什么样的规律，服从什么样的分布，如何选取先验分布是一个相当重要的问题，确定先验分布的方法有：客观法、主观概率法、同等物质原则、共轭分布法、Jeffreys原则、最大熵原则等。这里需要着重介绍的就是&lt;strong&gt;共轭分布法&lt;/strong&gt;。所谓的共轭分布就是指当 $P(D|H)$ 遵循某种分布时先验分布和后验分布遵循相同的分布形式，只是参数不同而已，例如常见的共轭分布有：Beta-Binomial 共轭、Dirichlet-Multinomial 共轭，结合上面提到的主题模型中得多项式分布，可以知道 LDA 模型中所采取的先验概率即为 Gamma 分布。&lt;/p&gt;
&lt;h3&gt;4. Beta-Binomial 共轭 &amp;amp; Dirichlet-Multinomial 共轭&lt;/h3&gt;
&lt;p&gt;在前面提到的二项分布中，频率派的观点认为抛一枚硬币正面朝上的概率应该是大量重复伯努利实验频率趋于的稳定值：$p = \frac{k}{n}$；而在贝叶斯派的眼中不应该存在一个确定的概率值 $p$，这个概率值应该服从于某一分布，例如 $p \sim X(\theta)$ ，从而二项分布在贝叶斯理论框架下变成了：
$$P(k; n, p) =  P(p)C_k^n p^k(1-p)^{n-k}$$
那么如何选取 $p$ 的先验分布呢？如上所述我们用共轭分布的方法选取 $p$ 的先验分布，当观察数据服从二项分布(Binomial)时，Beta 作为先验分布时后验分布也是 Beta 分布(&lt;a href="http://cos.name/2013/01/lda-math-beta-dirichlet/"&gt;证明过程&lt;/a&gt;)：
$$Be(p; \alpha, \beta) = \frac{p^{\alpha - 1}(1 - p)^{\beta - 1}}{ \int_0^1 \theta^{\alpha - 1}(1 - \theta)^{\beta - 1}d\theta}$$
类似的，多项式分布的共轭分布为 Dirichlet 分布：
$$Dir(k_1, k_2, ..., k_N; p_1, p_2, ..., p_N) = \frac{ \Gamma (\sum_{n=1}^N\alpha_n)}{\prod_{n=1}^N\Gamma(\alpha_n)}\prod_{n=1}^Np_n^{k_n - 1}$$
其中：
$$\Gamma (x) = \int_0^\infty  t^{x-1}e^{-t}$$&lt;/p&gt;&lt;script type= "text/javascript"&gt;
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
&lt;/script&gt;
</summary><category term="Psychology"></category><category term="统计"></category><category term="LDA"></category></entry><entry><title>关于编码的一切</title><link href="http://defsniky.com/posts/2014-01-16-All-about-encoding.html" rel="alternate"></link><updated>2014-01-16T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2014-01-16:posts/2014-01-16-All-about-encoding.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;乱码&lt;/strong&gt;与&lt;strong&gt;时间格式&lt;/strong&gt;错误如同矗立在所有程序员面前的两座大山。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编码错误或乱码几乎是每个人都会遇到的问题，比如用 Python 抓取网页进行正则分析之后发现在原来网页上正常的文字抓取下来之后变成乱码了，或者是存进 MySQL 之后变成乱码了，又或者本来在编辑器里面编辑得好好的输出之后又是乱码……要命的是每次遇到乱码问题，经过一番痛苦挣扎之后终于解决了，之后总是还会遇到新的乱码问题，这才是真正的“子子孙孙无穷尽也”，本文试图从头到尾将编码问题彻底阐述清楚，至少以后再次遇到&lt;code&gt;烫烫烫烫烫烫烫烫烫&lt;/code&gt;的问题能够有迹可循。&lt;/p&gt;
&lt;h3&gt;1. 什么是编码&lt;/h3&gt;
&lt;p&gt;中文 &lt;code&gt;雨&lt;/code&gt; 翻译成英文变为 &lt;code&gt;rain&lt;/code&gt; ，我们可以说是将中文这种以&lt;strong&gt;横竖撇捺&lt;/strong&gt;等简单笔画为基本元素的编码形式转换成了英文这种以 &lt;strong&gt;&lt;code&gt;a-z&lt;/code&gt;&lt;/strong&gt; 26个英文字母为基本元素的编码形式，同样在计算机的世界里面，一切事物都是由 0 和 1 这两个基本元素编码而成的，想象一下显示器上面所呈现出来的所有的精美绝伦的影像以及音响里传出的所有美妙乐章都源自于 0 和 1 这两个简单数字的复杂组合。&lt;/p&gt;
&lt;p&gt;编码问题从理论上来说也许并不复杂，只是从一种符号系统到另外一种符号系统之间的映射，但是在实际操作或者实施编码的过程中往往会出现很多问题(见第4部分)，我们需要将人类的意图翻译成机器能够理解的二进制编码，在计算机内部经过一系列的加工处理之后，又将这些二进制的信息重新编码成人类可以理解的自然语言（中文或者是英文甚至是图像、影音），对于英文来说，由于其语言构成的规律特性，只需要将其每一个元素（字母或简单符号）与二进制数进行一一对应，然后按照顺序排列就可以得到相应的单词、语句，因而简单的&lt;a href="http://zh.wikipedia.org/wiki/ASCII"&gt;ASCII编码系统&lt;/a&gt;已经足够应付，然而为了表示更多的语系或符号，我们就不得不 ASCII编码系统进行扩充，以容纳或者表示更多的语言符号，而乱码的问题也大多产生与此，接下来继续看一下计算机是如何对更多的语言符号进行编码的。&lt;/p&gt;
&lt;h3&gt;2. 如何编码&lt;/h3&gt;
&lt;p&gt;很巧的是编码格式与时间格式等问题以及许多计算机相关的问题都避免不了与&lt;strong&gt;格式&lt;/strong&gt;相关，统一的格式源自于相同的规则或者说标准(Standard)。ASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符(&lt;a href="http://zh.wikipedia.org/wiki/Ascii" title="wikipedia"&gt;Wiki&lt;/a&gt;)，在ASCII编码中每一个字符需要8位来表示，而8位一共可以编码&lt;code&gt;2**8 = 256&lt;/code&gt;个字符，这显然不足以将全世界各种不同语系、各种不同的符号涵盖在内，因而就需要将其进行扩展，也就是我们现在最常用的Unicode，现在 Unicode 仍然在不断增加，每次增加都会有新的字符被编码进来，Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符，每个字符占用2个字节，这样理论上一共最多可以表示&lt;code&gt;2**16 = 65536&lt;/code&gt;个字符，其中中文在Unicode表中所对应的二进制数字（转换成十六进制后）的范围是：&lt;code&gt;4E00 - 9FFF&lt;/code&gt;中日韩统一表意文字(CJK Unified Ideographs)。ASCII 与 Unicode 的编码方式就如同 C 语言中 &lt;code&gt;char&lt;/code&gt; 类型与 &lt;code&gt;int&lt;/code&gt; 类型的区别一样。&lt;/p&gt;
&lt;h3&gt;3. Unicode 与 UTF-8&lt;/h3&gt;
&lt;p&gt;Unicode是一种编码标准，比如说它规定汉字&lt;code&gt;雨&lt;/code&gt;对应的数字大小为&lt;code&gt;0x96e8&lt;/code&gt;（十进制38632），因而从本质上来说Unicode只是一张字符表(code table)，但是具体用什么方法来实现这种编码的转换，也有许多不同的选择，常见的UTF-8(8-bit Unicode Transformation Format)即是其中一种转换方法。(&lt;a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html#unicode"&gt;UTF-8 and Unicode FAQ&lt;/a&gt;)，其工作方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/utf-8.png" data-title="UTF-8" data-lightbox="example-set"&gt;
&lt;img alt="UTF-8" src="/images/utf-8.png" title="UTF-8" /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. 实现过程中的各个环节&lt;/h3&gt;
&lt;p&gt;字符从键盘输入到显示器显示出来，一般会经历下面几个过程：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/encoding-decoding-flow.png" data-title="Encoding flow" data-lightbox="example-set"&gt;
&lt;img alt="encoding-decoding-flow" src="/images/encoding-decoding-flow.png" title="Encoding-Decoding-FLow" /&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先是编码过程，这一过程与所用的&lt;strong&gt;编辑器&lt;/strong&gt;相关，以 vim 为例，当以 ASCII 的格式保存文件时，如果文件中含有 ASCII 字符之外的字符，则在保存的时候就会报错，因而需要将 vim 设置为 UTF-8 的编码格式（以UTF-8的方法保存、读取文件），方法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#file ~/.vimrc&lt;/span&gt;
&lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="nv"&gt;fileencoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;utf-8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大多数编辑器中出现乱码的问题多是由于保存格式的原因所导致，因此一般可以通过改变配置中的编码格式（如设为UTF-8）修复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对程序员来来说更关心的是在特定编程环境下，字符的编码是如何被加工处理的，下面就以 Python 2.7.5 为例加以解释。Python 2.x 中默认的编码格式为 ASCII：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;UTF-8的编码方式规定，Unicode范围由U+0800至U+FFFF的字符（如&lt;code&gt;雨&lt;/code&gt;）使用三个字节进行编码，其编码方式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;U+00000800 – U+0000FFFF &amp;lt;-&amp;gt; 1110xxxx 10xxxxxx 10xxxxxx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此一来，我们便知道会出现'\xe9\x9b\xa8'这种奇怪的乱码的原因是什么了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;rain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;雨&amp;#39;&lt;/span&gt;
rain
//Output &amp;gt;&amp;gt;&amp;gt; &lt;span class="s1"&gt;&amp;#39;\xe9\x9b\xa8&amp;#39;&lt;/span&gt;

rain.decode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
//Output &amp;gt;&amp;gt;&amp;gt; u&lt;span class="s1"&gt;&amp;#39;\u96e8&amp;#39;&lt;/span&gt;

rain.encode&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
//Raise error:
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;    Traceback (most recent call last):&lt;/span&gt;
&lt;span class="s2"&gt;    File &amp;quot;&lt;/span&gt;&amp;lt;stdin&amp;gt;&lt;span class="s2"&gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;    UnicodeDecodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t decode byte 0xe9 in position 0: ordinal not in range(128)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现上面编码错误的原因还要从UTF-8的编码方法中找，UTF-8使用3个字节对&lt;code&gt;雨&lt;/code&gt;字进行编码，得到的Unicode码为应为'\u96e8'，而其对应的UTF-8数字却为'e99ba8'（见上面UTF-8的编码方式中的xxxx），而这三个字节在 ASCII 中则被表示为'\xe9\x9b\xa8'，因此这一编码重新以UTF-8进行解码&lt;code&gt;rain.decode('utf8')&lt;/code&gt;仍然可以得到正确的Unicode，但是在ASCII环境下进行UTF-8编码则会报错，因为已经超出了ASCII的编码范围。解决这一问题的方法就是设定默认的编码方式为UTF-8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="nb"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39;Python 运行时会检查环境设置并删除setdefaultencoding方法，因而需要reload(sys)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后一步是关于解码的过程，即将计算机存储的二进制数转换成屏幕上显示出来的各式各样的字符，这一过程中产生的乱码一方面可能是由于系统不支持对某些字体的渲染甚至对于较旧的系统不支持某些特殊字符的显示，另一方面仍然可能是所配置的编码格式的问题，尝试将编码格式设置为UTF-8或许解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文试图理清计算机中关于编码的一系列概念，如 ASCII、Unicode、UTF-8等，并试图从编码及解码的各个层面找出可能出现乱码的原因，为以后能够更快地定位乱码错误原因提供参考。&lt;/p&gt;</summary><category term="Encoding"></category><category term="Python"></category></entry><entry><title>SICP 英文第二版</title><link href="http://defsniky.com/posts/2013-10-28-sicp-online-with-reader-friendly-style.html" rel="alternate"></link><updated>2013-10-28T00:00:00+08:00</updated><author><name>rainy</name></author><id>tag:defsniky.com,2013-10-28:posts/2013-10-28-sicp-online-with-reader-friendly-style.html</id><summary type="html">&lt;p&gt;&lt;a href="/projects/sicp/book-Z-H-4.html"&gt;SICP full-text&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;this is a copy from &lt;a href="http://mitpress.mit.edu/sicp/"&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://creativecommons.org/licenses/by-nc/3.0/" title="licenses"&gt;&lt;img alt="licenses" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /&gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="SICP"></category></entry></feed>